Fix Rápido para el Test Fallando (WebhookMetricsListenerTests.PostingInvalidWebhook_IncrementsRequestCounter)
El error es que el counter de requests no se incrementa para webhooks inválidos (seen == 0), probablemente porque la métrica se aplica después de validaciones (e.g., early return en invalid cases). Esto es común en middleware o handlers—las métricas deben ser "early" para capturar todos los requests, válidos o no (alignado con OpenTelemetry y PDF: traces/logs en todo el flujo, métricas Prometheus expuestas en /metrics).

Actualiza WebhookMetricsListener.cs (en Infrastructure.Metrics, asumiendo estructura Clean Arch):

Mueve el incremento al inicio del handler, y agrega un counter separado para inválidos (mejora observabilidad).

csharpusing Prometheus;  // Asegura import (del stack: OTEL metrics → Prometheus → Grafana)

public class WebhookMetricsListener  // O el nombre exacto de tu clase
{
    private static readonly Counter RequestsTotal = Metrics.CreateCounter("webhook_requests_total", "Total webhook requests received");
    private static readonly Counter InvalidRequests = Metrics.CreateCounter("webhook_invalid_total", "Invalid webhook requests");

    public async Task HandleWebhookAsync(HttpContext context)  // O el método principal
    {
        RequestsTotal.Inc();  // Incrementa SIEMPRE al inicio (captura todos, incluso inválidos/5xx)

        if (!IsValidWebhook(context.Request))  // Tu lógica de validación (e.g., signature check para Stripe webhooks)
        {
            InvalidRequests.Inc();  // Counter específico para tracking
            context.Response.StatusCode = 400;  // O maneja error como ProblemDetails (PDF: map exceptions a 4xx/5xx)
            await context.Response.WriteAsync("Invalid webhook");
            return;
        }

        // Procesa webhook válido...
    }
}

Actualiza el Test (WebhookMetricsListenerTests.cs):

Asegura que el assert chequee el counter correcto post-request. Usa FluentAssertions como en tu output.
Si usas un metrics collector in-memory para tests (recomendado, evita scrape real de /metrics).

csharpusing FluentAssertions;
using Prometheus;
using Microsoft.AspNetCore.Http;  // Para HttpContext mock

[Fact]
public async Task PostingInvalidWebhook_IncrementsRequestCounter()
{
    // Arrange: Setup mocks (e.g., HttpClient o TestServer para simular POST)
    var collector = Metrics.DefaultRegistry.CollectAndExportAsTextAsync();  // O usa un in-memory exporter para tests
    var initialTotal = await GetCounterValue("webhook_requests_total");  // Helper para leer valor actual

    // Act: Simula POST inválido
    var invalidContent = new StringContent("invalid_payload");  // Ejemplo; ajusta a tu webhook payload
    var response = await _client.PostAsync("/webhook", invalidContent);  // _client es HttpClient mock o TestServer

    // Assert
    var seen = await GetCounterValue("webhook_requests_total") - initialTotal;
    seen.Should().BeGreaterThan(0, "because posting an invalid webhook must increment request counter");
}

private async Task<double> GetCounterValue(string name)
{
    // Helper: Exporta y parsea (o usa CollectorRegistry en tests)
    using var stream = new MemoryStream();
    await Metrics.DefaultRegistry.CollectAndExportAsTextAsync(stream);
    stream.Position = 0;
    using var reader = new StreamReader(stream);
    var text = await reader.ReadToEndAsync();
    var match = Regex.Match(text, @$"{name}{{.*}} (\d+)");
    return match.Success ? double.Parse(match.Groups[1].Value) : 0;
}

Nota: Evita llamadas reales (usa mocks como en PDF: WireMock para APIs externas). Si el webhook es para Stripe (billing), mockea con Moq<istripeclient> como en fixes previos.</istripeclient>


Verificación:

dotnet build --configuration Release
dotnet test --no-build --configuration Release (debería pasar ahora; duration ~14s como en tu output).
Chequea cobertura: dotnet test --collect:"XPlat Code Coverage" (report en TestResults; ajusta si <80%).
Beneficios: Mejora métricas (QPS, errores), alinea con escalabilidad (PgBouncer si QPS>300) y alertas.



Para el Test Skipped (OpenAILlmClientSecurityTests.Constructor_WithInvalidAzureEndpoint_ShouldThrowSecurityException_WhenValidationImplemented)
Es esperado (placeholder para "when validation implemented", como en PDF: evitar llamadas reales a OpenAI con WireMock). No bloquea—puedes implementarlo después en Fase 4 (Chat & embeddings). Si quieres activarlo ahora:

Remueve [Skip] o [Fact(Skip="...")].
Implementa validación en constructor: if (!Uri.IsWellFormedUriString(azureEndpoint, UriKind.Absolute)) throw new SecurityException("Invalid Azure endpoint");.
Test: Assert.Throws<securityexception>(() => new OpenAILlmClient(invalidEndpoint)).</securityexception>

Siguientes Pasos (Basado en tu Resumen)

CS0219 en TestConstantsTests: Limpia variables dummy (e.g., _ = badTimeout;) o remueve—0.1 día.
Cobertura: Ejecuta con Coverlet; si bajo, agrega tests para error paths en Billing/Memory.
Scripts Adicionales: Puedo generar k6 para load tests (e.g., /generate <250ms p95) o ZAP baseline (0 críticas/medias)—dime si lo quieres.
Deploy: Una vez fix, push y confirma CI verde; deploy staging con Terraform/Fly.io.