1) CodeStandardsTests.GetSolutionPath() — cache + búsqueda robusta y acotada
Problema: Recorre directorios sin límite y depende de GetCurrentDirectory().
Riesgo: latencias intermitentes en CI, resultados no deterministas si el runner cambia el CWD.

Fix (drop‑in): cache con Lazy<string>, override por ENV, límite de profundidad y fallback al raíz del repo (detectando .git o Directory.Build.props). Esto evita coste por prueba y cumple el objetivo de tiempos p95 consistentes. Plan_Backend_AutoDocOps…


// En CodeStandardsTests.cs (clase estática o dentro del test class como static)
private static readonly Lazy<string> _solutionPath = new(() =>
{
    // 1) Override opcional en CI/local
    var env = Environment.GetEnvironmentVariable("SOLUTION_ROOT");
    if (!string.IsNullOrWhiteSpace(env) && Directory.Exists(env)) return Path.GetFullPath(env);

    // 2) Base estable: ubicación del ensamblado de tests
    var dir = new DirectoryInfo(AppContext.BaseDirectory);
    const int maxHops = 12; // cota dura para evitar recorridos largos
    int hops = 0;

    while (dir != null && hops++ < maxHops)
    {
        // Preferencias de marcador de raíz
        if (dir.GetFiles("*.sln").Length > 0) return dir.FullName;
        if (dir.GetDirectories(".git").Length > 0) return dir.FullName;
        if (dir.GetFiles("Directory.Build.props").Length > 0) return dir.FullName;
        dir = dir.Parent;
    }

    throw new InvalidOperationException("Solution root not found within bounded search.");
});

private static string GetSolutionPath() => _solutionPath.Value;
Extra: documenta en el pipeline SOLUTION_ROOT para evitar búsquedas. (Alinea con CI/CD claro y reproducible.) Plan_Backend_AutoDocOps…

2) Constante duplicada en overflow test — única fuente de verdad
Problema: OverflowTriggerOffsetTicks redefinida en el test.
Riesgo: drift al cambiar valores.

Fix (drop‑in):


-    private const long OverflowTriggerOffsetTicks = 1000;

 [Fact]
 public void BackoffHelperCheckedArithmeticOnOverflowReturnsMax()
 {
     // Arrange - value chosen to overflow when doubled
-    var overflowProneValueTicks = checked(long.MaxValue - OverflowTriggerOffsetTicks);
+    var overflowProneValueTicks = checked(long.MaxValue - TestConstants.Overflow.OverflowTriggerOffsetTicks);
Si TestConstants.Overflow aún no existe, muévela a un único archivo compartido dentro de tests/AutoDocOps.Tests/TestConstants.cs.

3) ReadBodyAtMostAsync — buffer incremental y presión de memoria baja
Problema: ArrayPool<byte>.Shared.Rent(maxBytes) siempre renta el tamaño máximo (256 KiB), aunque el cuerpo sea pequeño.
Riesgo: presión de GC/LOH bajo carga (webhooks concurrentes). El plan exige p95 estable y métricas finas. Plan_Backend_AutoDocOps…

Fix (drop‑in): crecimiento exponencial, BodyReader, cota dura y devolución correcta al pool.


static async Task<(bool ok, string body, bool tooLarge)> ReadBodyAtMostAsync(
    HttpRequest request, int maxBytes, CancellationToken ct)
{
    var reader = request.BodyReader;
    var pool = ArrayPool<byte>.Shared;

    var capacity = Math.Min(8192, maxBytes); // 8 KiB inicial
    byte[] buffer = pool.Rent(capacity);
    int written = 0;

    try
    {
        while (true)
        {
            ReadResult read = await reader.ReadAsync(ct);
            var buf = read.Buffer;

            foreach (var segment in buf)
            {
                var needed = written + segment.Length;
                if (needed > maxBytes)
                    return (false, string.Empty, tooLarge: true);

                if (needed > buffer.Length)
                {
                    // crecer ~x2 sin superar maxBytes
                    var newSize = Math.Min(Math.Max(buffer.Length * 2, needed), maxBytes);
                    var newBuf = pool.Rent(newSize);
                    Buffer.BlockCopy(buffer, 0, newBuf, 0, written);
                    pool.Return(buffer, clearArray: false);
                    buffer = newBuf;
                }

                segment.CopyTo(buffer.AsSpan(written));
                written += segment.Length;
            }

            reader.AdvanceTo(buf.End);

            if (read.IsCompleted) break;
        }

        var body = Encoding.UTF8.GetString(buffer, 0, written);
        return (true, body, tooLarge: false);
    }
    finally
    {
        pool.Return(buffer, clearArray: false);
    }
}
Complemento: centraliza el límite por endpoint en opciones:


builder.Services.Configure<WebhookLimitsOptions>(o => o.MaxBytes = 256 * 1024);
y úsalo en RequestSizeLimitAttribute para coherencia operativa. (Métrica/alerta si hay tooLarge.) Plan_Backend_AutoDocOps…

4) HandleStripeWebhookAsync — separa responsabilidades + seguridad / latencia
Problema: método >100 líneas con validación, parseo, procesamiento y auditoría mezclados.
Riesgo: difícil de testear, eleva complejidad ciclomática, posibilidad de errores “silenciosos”. El plan pide logs estructurados, métricas con Prometheus y rate‑limit global. Plan_Backend_AutoDocOps… Plan_Backend_AutoDocOps…

Refactor propuesto (estructura):


app.MapPost("/stripe/webhook", HandleStripeWebhookAsync)
   .Accepts<string>("application/json")
   .RequireRateLimiting("stripe-webhook")
   .WithRequestTimeout(TimeSpan.FromSeconds(5))
   .WithMetadata(new RequestSizeLimitAttribute(WebhookLimits.MaxBytes))
   .WithName("StripeWebhook").WithTags("Billing").AllowAnonymous();

static async Task<IResult> HandleStripeWebhookAsync(HttpContext ctx, ILogger<Program> log, IStripeService stripe, IWebhookMetrics metrics, IAuditSink audit, IOptions<WebhookLimitsOptions> opt, CancellationToken ct)
{
    var sw = ValueStopwatch.StartNew();
    try
    {
        var (ok, raw, tooLarge) = await ReadBodyAtMostAsync(ctx.Request, opt.Value.MaxBytes, ct);
        if (!ok) { metrics.ObserveInvalid("stripe", tooLarge ? "too_large" : "read_error"); return Results.StatusCode(StatusCodes.Status413PayloadTooLarge); }

        var evt = ValidateAndParseStripeEvent(ctx.Request, raw, log, metrics);
        if (evt == null) return Results.StatusCode(StatusCodes.Status400BadRequest);

        await ProcessStripeEventAsync(evt, stripe, metrics, ct);
        _ = audit.TryWriteAsync(new AuditRecord("stripe", evt.Id, evt.Type, ctx.TraceIdentifier)); // fire-and-forget
        return Results.Ok();
    }
    catch (OperationCanceledException)
    {
        metrics.ObserveTimeout("stripe"); return Results.StatusCode(StatusCodes.Status504GatewayTimeout);
    }
    catch (StripeSignatureException sig)
    {
        log.ErrorProcessingStripeWebhook("signature_invalid", sig);
        metrics.ObserveInvalid("stripe", "sig_invalid");
        return Results.StatusCode(StatusCodes.Status401Unauthorized);
    }
    catch (Exception ex)
    {
        log.ErrorProcessingStripeWebhook("other", ex);
        metrics.ObserveInvalid("stripe", "other");
        return Results.StatusCode(StatusCodes.Status500InternalServerError);
    }
    finally
    {
        metrics.ObserveLatency("stripe", sw.GetElapsedTime());
    }
}

static StripeEvent? ValidateAndParseStripeEvent(HttpRequest req, string raw, ILogger log, IWebhookMetrics metrics)
{
    // Aquí valida firma (header), tolerancias, tipo de contenido, etc.
    // Devuelve null si inválido, levantando métricas específicas.
    // Usa LoggerMessage y no strings literales.
    ...
}

static Task ProcessStripeEventAsync(StripeEvent evt, IStripeService svc, IWebhookMetrics metrics, CancellationToken ct)
{
    // Switch por tipo, idempotencia por EventId, reintentos internos si aplica
    ...
}
Beneficios: pruebas unitarias por función, logs con LoggerMessage, métrica de latencia p95 y etiquetado por causa de fallo (sig_invalid, too_large…). Encaja con las prácticas de observabilidad y rate‑limit del plan. Plan_Backend_AutoDocOps… Plan_Backend_AutoDocOps…

5) Heurística IsInTestOrCommentContext — Roslyn light en vez de cadenas
Problema: condicionales largas y frágiles; TODO pendiente.
Riesgo: falsos positivos/negativos al escanear strings “hardcoded”.

Fix (robusto y rápido): usa Roslyn para separar comentarios (trivia) y string literals; y para “contexto de test”, decide por atributo [Fact]/[Theory] o clase *Tests. El proyecto ya contempla microservicio Roslyn y xUnit, por lo que añadir Microsoft.CodeAnalysis.CSharp en tests es coherente con el stack. Plan_Backend_AutoDocOps… Plan_Backend_AutoDocOps…


private static bool IsInTestOrCommentContext(string filePath, int position)
{
    var text = File.ReadAllText(filePath);
    var tree = CSharpSyntaxTree.ParseText(text);
    var root = tree.GetRoot();

    // 1) Comentarios
    var trivia = root.FindTrivia(position, findInsideTrivia: true);
    if (trivia.IsKind(SyntaxKind.SingleLineCommentTrivia) || trivia.IsKind(SyntaxKind.MultiLineCommentTrivia))
        return true;

    // 2) Test methods o clases *Tests
    var token = root.FindToken(position);
    var method = token.Parent?.AncestorsAndSelf().OfType<MethodDeclarationSyntax>().FirstOrDefault();
    var type = token.Parent?.AncestorsAndSelf().OfType<ClassDeclarationSyntax>().FirstOrDefault();

    bool inTestMethod = method?.AttributeLists
        .SelectMany(a => a.Attributes)
        .Any(a => a.Name.ToString().Contains("Fact") || a.Name.ToString().Contains("Theory")) == true;

    bool inTestsClass = type?.Identifier.ValueText.EndsWith("Tests", StringComparison.Ordinal) == true;

    return inTestMethod || inTestsClass;
}
Resultado: inspección de estándares más precisa y estable.

APLICAR TESTS PARA VALIDAR LO APLICADO


Conjunto A (Puntos 1–5): estabilidad en tiempo de ejecución y robustez
GetSolutionPath: caché + búsqueda acotada
Tests propuestos (unit):

GetSolutionPath_UsesEnvOverride_WhenSet: si SOLUTION_ROOT existe, lo prioriza.

GetSolutionPath_BoundedSearch_MaxDepth: no recorre más de N niveles (evita “walks” infinitos).

GetSolutionPath_FindsRepoRoot_ByMarkers: detecta .sln/.git/Directory.Build.props.
(Impacto: CI estable y reproducible, base para tiempos p95 consistentes en el pipeline.)

Constante de overflow: única fuente de verdad
Tests propuestos (unit):

BackoffHelper_Overflow_UsesSharedConstant: el test referencia TestConstants.Overflow.OverflowTriggerOffsetTicks (no redefinida).

BackoffHelper_DoubleOverflow_ReturnsMax: con valor propenso a overflow, NextDelay devuelve maxDelay (no lanza).
(Impacto: elimina drift y falsos verdes en CI.)

ReadBodyAtMostAsync: buffer incremental (menos presión de memoria)
Tests propuestos (unit + “micro‑integ” con BodyReader fake):

ReadBodyAtMost_SmallPayload_NoResize: para ≤8KiB no crece el buffer.

ReadBodyAtMost_GrowsExponentially_UntilNeeded: verifica escalado ~x2 sin exceder maxBytes.

ReadBodyAtMost_TooLarge_Returns413Flag: marca tooLarge y el caller responde 413.
(Impacto: GC más predecible durante picos, clave para p95 bajo carga.)

HandleStripeWebhookAsync: separar validación, parseo, proceso y auditoría
Tests propuestos (integration-light con server in‑memory):

StripeWebhook_InvalidSignature_Returns401_MetricsTagged: 401 y webhook_invalid_total{reason="sig_invalid"} incrementa.

StripeWebhook_TooLarge_Returns413: cuando excede RequestSizeLimit.

StripeWebhook_ValidEvent_200_ProcessesOnce: idempotencia por EventId (no reprocesa).

StripeWebhook_Timeout_504_Observed: simula OperationCanceledException → 504 + métrica de timeout.
(Impacto: mantenibilidad + seguridad; mapea correctamente 4xx/5xx y observa latencias/causas.)

IsInTestOrCommentContext → Roslyn “light”
Tests propuestos (unit, sobre archivos sintéticos):

Detector_Comments_AreIgnored: strings dentro de comentarios no cuentan como “hardcoded”.

Detector_FactOrTheory_Methods_AreTestContext: literals en métodos [Fact]/[Theory] se ignoran para la regla.

Detector_NonTestCode_FindsHardcodedString: literal en código productivo dispara la violación de estándar.
(Impacto: menos falsos positivos en tu prueba de estándares; disciplina sin ruido.)